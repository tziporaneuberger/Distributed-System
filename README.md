# Distributed-System-
Our distributed system begins with the ThreadedMasterServer which has an ArrayList of MasterThreads. Each MasterThread connect to a different Slave server through the use of sockets. The ThreadedMasterServer begins with initializing three port numbers and creating a ServerSocket for each port. Our distributed system currently has two Slaves, but it can support many more if more ports are opened and more ServerSockets are created for communication with the slaves. Of the three ServerSockets currently instantiated, the first is used in the ThreadedMasterServer to connect to the Client, and the next two are sent to the MasterThreads in their constructors to use for connecting to the Slaves.
 
       The client is the interface that interacts with the user. It uses the IP-Address and first port number of the ThreadedMasterServer to create a socket that will communicate with the ThreadedMasterServer.  The Client asks the user to enter the job ID of the job that he wants done and sends it to the ThreadedMasterServer. After each job ID is sent to the Server, the user is given the option to choose another job for the server to complete or not. The user’s response is forwarded to the ThreadedMasterServer.
 
       The ThreadedMasterServer reads in the job ID sent by the Client. It then starts the load balancing algorithm for the distributed system. The algorithm loops through the ArrayList of MasterThreads to get the total ranking for each of the slaves, which the MasterThreads keep a count of. The job ID is then sent to the MasterThread which connects to the slave with the lowest ranking. When the MasterThread receives a new job ID, it creates a new Job based on the ID, and the Job class instantiates the ranking of the job. The MasterThread places the Job temporarily in its own queue (the “newJobsQueue”), until the Slave is finished the job it is in middle of and is ready to receive new jobs to add to its queue.
 
       The distributed system keeps on running until the Client informs the server that the user has no more jobs to request. When the ThreadedMasterServer receives this message, it sets the “receivingMoreJobs” boolean variable in each of the MasterThreads to false. The MasterThreads will then keep on running only as long as there are still more “old” jobs that the Slave needs to complete. When the MasterThreads have determined that the Slaves completed all of their old jobs, they will let the slaves know that all of the jobs are complete. The Slave classes then close. The ThreadedMasterServer then “joins” the MasterThread threads and the MasterThread classes close. The ThreadedMasterServer informs the Client that all of the jobs the user requested were completed successfully and the ThreadedMasterServer class closes. The Client then informs the user that all of the jobs were successfully completed, and the Client class is the last to close.

